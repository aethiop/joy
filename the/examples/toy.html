<script src="https://cdn.jsdelivr.net/npm/acorn@8.14.1/dist/acorn.min.js"></script>
<script class="SecureRender" src="../content.js">
the.start = the.start || (async () => {

  setTimeout(() => {
    var code = `
let a = 1;
var b = 2, c = a + b;

var multiply = function(x,y){
  return x * y;
}
`;

    var ast = acorn.parse(code,{ecmaVersion: 2022, sourceType: 'module'});

    render(ast);
  }, 1);

})();

/* ---- the Code from Phone TOY is below ------ */

/**
-[ ] fix do while to retain structure
-[ ] switch broke as well
-[ ] render ? for optional chaining
-[ ] else 
*/
    function render(ast) {
    
    if (!ast) { return }
    console.log("AST:", ast);
    
    // Renders body
    // Container node: either a program or a block, so process accordingly.
    if(ast.body && !(ast.left || ast.right) && !(ast.test || ast.init || ast.update)){
      if(ast.id){ // named function, convert to left/right:
        render.act(ast);
        return;
      }
      ast.up = ast.up || '';
      ast.$id = ast.$id || render.id(ast);
      if(!ast.up){
        //render.the({name: ast.$id, fill: [1,1,1,0]});
        render.the({
          name: ast.$id+'-start',
          size: [[1, '~'], [1, '~']],
          sort: [0.1, ast.up.$id]
        }).the({ // make label
          name: ast.$id+'-start-text',
          sort: [0.1, ast.$id+'-start'],
          fill: "",
        });
      }
      render.the({ // make view
        name: ast.$id,
        size: [[1,'~'],[1,'~']],
        sort: [0.1, ast.up.$id],
        fill: ast.up? render.fill(ast) : undefined
      });
  
      if((ast.up.params || ast.params)/* && (ast.params || ast.up.params || '').length > 0*/){ // treat parameters as first line.
        render.list(ast, ast.up.params || ast.params, 'function(', ',', ')');
      }
      render.list(ast, ast.body.body || ast.body, '', ';', ';');
      return;
    }

    if(ast.declarations || ast.expressions || ast.elements){
  
      ast.up = ast.up || '';
      ast.$id = ast.$id || render.id(ast);

      render.list(ast, ast.declarations||ast.expressions||ast.elements);
      return;
    }
    render.flow(ast);
    if (!['ForStatement', 'ForInStatement', 'ForOfStatement'].includes(ast.type)) {
        render.act(ast);
    }
  }

  // Process an AST node as an "action" node, handling basic nodes such as identifiers, literals,
  // as well as special cases like 'this', async markers, and class declarations.
  render.act = function(ast){
    if(!ast){ return }
  
    //if(ast.raw){ // end!
    // Handle basic nodes (literals and identifiers)
    // literal or identifier node: render text label.
    if(ast.raw || 'Identifier' == ast.type || ast.local || ast.imported){ // end!
      ast.$id = ast.$id || render.id(ast);
      render.the({ // make view
        name: ast.$id,
        fill: render.fill(ast),
        sort: [0.1, ast.up.$id]
      }).the({
        name: ast.$id+'-text',
        sort: [0.1, ast.$id],
        fill: (ast.local || ast.imported || '').name || ast.raw || ast.name,
      });
      return;
    }

    if (ast.type === 'ThisExpression') {
      render.the({
        name: ast.$id,
        fill: render.fill(ast),
        sort: [0.1, ast?.up?.$id || ast.$id]
      }).the({
        name: ast.$id + '-text',
        sort: [0.1, ast.$id],
        fill: "this",
      });
      // console.log("***AST:", ast)
    }
    
    // Mark this node as async.
    if (ast.async) { // handle async
      render.the({
        name: ast.$id + '-async',
        fill: "async",
        sort: [0.1, ast.$id],
      });
    }
    // handle class
    // Special handling for class declarations.
    if (ast.type === 'ClassDeclaration') {
      render.the({
        name: ast.$id + '-class',
        fill: "class",
        sort: [0.1, ast.$id],
      }).the({
        name: ast.$id + '-text',
        sort: [0.1, ast.$id + '-class'],
        fill: ast.id && ast.id.name ? ast.id.name : "unnamed class",
      });
    }
    var act = render.actify(ast);

    // If we found a class body, treat it as a separate expression:
    if (act.body) {
      // For clarity, store the class body so we can render it after the main expression
      act.classBody = act.body;
      delete act.body;
    }
    
    ast.up = ast.up || '';
    ast.$id = ast.$id || render.id(ast);

    var left = act?.left,
      op = act?.operator,
      right = act?.right

    render.expression(ast, left, op, right);
  }
  // Helper: Determine how to "actify" an AST node by extracting its left/right/operator/other elements.
  render.actify = function (ast) {
    // Handle conditional expressions (ternary operators)
    if (ast.type === 'ConditionalExpression') {
      // Make sure we mark this as a conditional expression for special handling
      var act = { 
        left: ast.test, 
        operator: '?', 
        right: ast.consequent,
        alternate: ast.alternate,
        isConditional: true,
        type: 'ConditionalExpression'
      };
      
      // Process the alternate side - this could be a nested conditional
      if (ast.alternate && ast.alternate.type === 'ConditionalExpression') {
        ast.alternate.up = ast;
        // Already a conditional, will get processed separately
      } else if (ast.alternate) {
        ast.alternate.up = ast;
      }
      
      return act;
    }
    
    if (ast.left && ast.right) {
      act = ast;
      act.operator = ast.operator || '=';
      // Special handling for nullish coalescing operator
      if (act.operator === '??') {
        // Handle nullish coalescing operator specially
        act.isNullishCoalescing = true;
      }
    } else if (ast.key && ast.value) { 
      act = { left: { property: ast.key }, operator: '=', right: ast.value}
    } else if (ast.expression) {
      ast.expression.back = ast;
      act = ast = ast.expression;
    // For arrow functions: treat parameters as left and body as right.
    } else if (ast.type === 'ArrowFunctionExpression') {
      act = { left: ast.params, operator: 'â‡’', right: ast.body };
    } else if (ast.params) {
      ast.body.up = ast;
      act = { left: { property: ast.id }, operator: "=", right: ast.body };
    } else if ("VariableDeclaration" == ast.type || "VariableDeclarator" == ast.type) {
      let l =  ast.id || ast.declarations?.[0]?.id, r = ast.init || ast.declarations?.[0]?.init;
      act = { left: l, operator: l && r ? "=" : '', right:r};
    } else if (ast.type === 'ObjectPattern') {
      act = { left: ast.properties, operator: '=', right: null };
    } else if (ast.type === 'ArrayPattern') {
      act = { left: ast.elements, operator: '=', right: null };
    } else if (ast.type === 'AssignmentPattern') {
      act = { left: ast.left, operator: '=', right: ast.right };
    } else if (ast.type === 'LogicalExpression' && ast.operator === '??') {
      // Handle nullish coalescing operator in logical expressions
      act = { left: ast.left, operator: '??', right: ast.right, isNullishCoalescing: true };
    } else if (ast.type === 'ClassDeclaration' || ast.type === 'ClassExpression') {
      // Gracefully unify class into left/operator/right:
      // left = class name, operator = 'extends' (if any), right = superClass
      // Then treat the entire "class body" as another expression or property
      let leftPart = ast.id || { name: 'anonymous' };
      let op = ast.superClass ? 'extends' : 'class';
      act = {
        left: leftPart,
        operator: op,
        right: ast.superClass || { name: 'Object' } // Assume no super => Object
      };
      // Also store the class body in a subproperty for the final expression step
      act.body = ast.body;
    } else if (ast.type === 'NewExpression') {
      act = { operator: 'new', left: ast.callee, right: ast.arguments };
    } else if (ast.callee) {
      ast.callee.back = ast;
      console.log("AST:", ast);
      // Check if the callee is empty or if there are no arguments (or if it's already invoked)
      act = { left: ast.body || ast.callee, operator: ''/*String.fromCharCode(8594)*/, right: ast.arguments };
      // Do not render redundant "()" if the node is already invoked elsewhere or has no parameters.
    } else if (ast.source && ast.specifiers) {
      act = { left: ast.specifiers, operator: 'from', right: ast.source };
    } else if (ast.declaration) { 
      act  = { operator: 'export', right: ast.declaration };
    } else if (ast.type === 'UpdateExpression') {
      if (ast.prefix) {
         act = { operator: ast.operator, right: ast.argument };
      } else {
         act = { operator: ast.operator, left: ast.argument };
     }
    } else if (ast.operator && ast.argument) {
      act = { left: ast.prefix ? null : ast.argument, operator: ast.operator, right: ast.prefix ? ast.argument : null };
    } else if (ast.type === 'AwaitExpression') { 
      act = { operator: "await", right: ast.argument };
    } else if (ast.type === 'YieldExpression') {
      act = { operator: "yield", right: ast.argument };
    } else if (ast.type === 'MemberExpression') {
      let op = ast.optional ? '?.' : '.'
      act = { left: ast.object, operator: op, right: ast.property };
      if (ast.object.type === "ThisExpression") {
        act.left = {type: "Identifier", name: "this"}
      }
    } else if (ast.type === 'OptionalMemberExpression') {
      act = { left: ast.object, operator: '?.', right: ast.property };
    } else if (ast.type === 'OptionalCallExpression') {
      act = { left: ast.callee, operator: '?.', right: ast.arguments };
    } else if (ast.type === 'SpreadElement' || ast.type === 'RestElement') {
      act = { operator: '...', right: ast.argument };
    } else if (ast.type === "ThisExpression") {
      act = {left: "this"}
    } else if (ast.type === 'ReturnStatement') {
      act = { operator: 'return', right: ast.argument };
    } else if (ast.type === 'ThrowStatement') {
      act = { operator: 'throw', right: ast.argument};
    } else if (ast.superClass) {
      act = {operator: 'extends', right: ast.superClass}
    }else if (ast.type === 'Property') {
      var s = !ast.shorthand && ast.kind === 'init';
      var k = ast.kind !== 'init';
      act = { left: ast.key, operator: s && ':' || k &&  ast.kind , right: (s || k) && ast.value};
    } else if (ast.type === 'ConditionalExpression') {
      act = { left: ast.test, operator: '?', right: ast.consequent };
      act.alternate = ast.alternate;
    } else if (ast.type === 'TemplateLiteral') {
      act = { operator: 'template', parts: [] };
      for (let i = 0; i < ast.quasis.length; i++) {
          act.parts.push(ast.quasis[i].value.raw);
          if (ast.expressions[i]) {
              act.parts.push(ast.expressions[i]);
          }
      }
    } else if (ast.type === 'SequenceExpression') {
      act = { operator: 'sequence', expressions: ast.expressions };
    } else if (ast.type === 'ObjectExpression') {
      act = { operator: 'object', properties: ast.properties };
    } else if (ast.body) {
      act = { operator: 'return', right: ast.body };
    } else {
      act = ast;
    }
    return act;
  }
  render.view = function (ast) {
    render.the({ // make view
      name: ast.$id,
      fill: render.fill(ast),
      sort: [0.1, ast.up.$id]
    })
  }
  // Process control flow nodes (e.g., if statements, loops, try/catch) and render their parts.
  render.flow = function (ast) {
    if (!ast) return;
    ast.$id = ast.$id || render.id(ast);
  
    if (ast.block) {
      ast.block.up = ast;
      // Handle if-else structure: render test and consequent parts.
      render.view(ast);
      render.the({
        name: ast.$id + '-text',
        sort: [0.1, ast.block.up.$id],
        fill: 'try',
      });
      render(ast.block);
      if (ast.handler) {
        render.view(ast);
        render.list(ast, [ast.handler], 'catch');
      }
      if (ast.finalizer) {
        render.view(ast);
        render.list(ast, [ast.finalizer], 'finally');
      }
    } else if (ast.discriminant && ast.cases) {
      // Improved switch statement handling
      ast.discriminant.up = ast;
      render.view(ast);
      render.the({
        name: ast.$id + '-text',
        sort: [0.1, ast.discriminant.up.$id],
        fill: 'switch',
      });
      render.list(ast, [ast.discriminant], '(', '', ')');
      
      // Handle each case separately with proper break statements
      for (let i = 0; i < ast.cases.length; i++) {
        const caseItem = ast.cases[i];
        caseItem.up = ast;
        
        // Handle default case differently
        if (!caseItem.test) {
          render.the({
            name: ast.$id + '-default-' + i,
            sort: [0.1 + (i * 0.01), ast.$id],
            fill: 'default:',
          });
        } else {
          // Regular case
          console.log("TODO: BUG! switch case", caseItem);
          render.the({
            name: ast.$id + '-case-' + i,
            sort: [0.1 + (i * 0.01), ast.$id],
            fill: 'case',
          });
          caseItem.test.up = caseItem.up;
          render(caseItem.test);
          render.the({
            name: ast.$id + '-case-colon-' + i,
            sort: [0.1 + (i * 0.01) + 0.001, ast.$id],
            fill: ':',
          });
        }
        
        // Render the consequent statements
        render.list(ast, caseItem.consequent);
      }
    } else if (ast.init && ast.test && ast.update) {
      render.view(ast);
      render.list(ast, [ast.init, ast.test, ast.update], 'for (', ';', ')');
    } else if (ast.type === 'DoWhileStatement') {
      ast.test.up = ast;
      render.view(ast);
      render.list(ast, [ast.test], 'while (', '', ')');
      render.list(ast, ast.body.body || ast.body, 'do ', '', '');
    } else if (ast.body && ast.left && ast.right) {
      render.view(ast);
      render.list(ast, [ast.left, ast.right], 'for (', (ast?.type === "ForInStatement" || ast?.type === "ForOfStatement") ? (ast?.type === "ForInStatement" ? 'in' : 'of') : 'for', ')');
      render.list(ast, ast.body.body || ast.body, '{', '', '}');
    } else if (ast.test && (ast.alternate || ast.consequent)) {
      render.view(ast);
      // Special handling for negation in test condition
      render.list(ast, [ast.test], 'if (', '', ')');
      render.list(ast, [ast.consequent], '{', '', '}');
      if (ast.alternate) {
        render.view(ast);
        render.list(ast, [ast.alternate], 'else', '', '');
      }
    } else if (ast.test) {
      render.view(ast);
      render.list(ast, [ast.test], 'while (', '', ')');
    } else if (ast.type === 'BreakStatement') {
      // Turn 'break' into a minimal "operator" expression
      const act = { operator: 'break' };
      render.view(ast);
      render.expression(ast, null, act.operator, null);
    } else if (ast.type === 'ContinueStatement') {
      // Similarly, 'continue' as an operator
      const act = { operator: 'continue' };
      render.view(ast);
      render.expression(ast, null, act.operator, null);
    } else if (ast.type === 'DebuggerStatement') {
      // 'debugger' as an operator
      const act = { operator: 'debugger' };
      render.view(ast);
      render.expression(ast, null, act.operator, null);
    } else if (ast.type === 'EmptyStatement') {
      // Do nothing, but keep log for clarity
      console.debug("Empty statement encountered:", ast);
    } else if (ast.type === 'LabeledStatement') {
      // 'label: statement' => treat label as left, statement as right, operator=':'
      ast.body.up = ast;
      const act = { left: { name: ast.label.name }, operator: ':', right: ast.body };
      render.view(ast);
      render.expression(ast, act.left, act.operator, act.right);
    } else if (ast.type === 'WithStatement') {
      // 'with (obj) body' => treat obj as left, operator='with', body as right
      ast.object.up = ast;
      ast.body.up = ast;
      const act = { left: ast.object, operator: 'with', right: ast.body };
      render.view(ast);
      render.expression(ast, act.left, act.operator, act.right);
    } else {
      // Final fallback
      console.warn("Unrecognized flow node type:", ast.type, ast);
    }
  }

  // Render an expression by separately processing the left-hand part, operator, and right-hand part.
  render.expression = function (ast, left, operator, right) {
    render.view(ast);

    // Special handling for ternary operator
    if (ast.type === 'ConditionalExpression' || ast.isConditional) {
      // Render the test condition (left side)
      if (left) {
        path = render.path(ast, {object: left})
        left.up = ast;
        render.side(left, ast, path, 'condition');
      }

      // Render the ? part
      render.the({
        name: ast.$id+'-ternary-question',
        sort: [0.3, ast.$id]
      }).the({
        name: ast.$id+'-ternary-question-text',
        sort: [0.1, ast.$id+'-ternary-question'],
        fill: '?',
      });

      // Right side is the "true" part of the conditional
      if (right) {
        right.up = right.up || ast;
        path = render.path(ast, {object: right});
        render.side(right, ast, path, 'ifTrue');
      }

      // Render the : part
      render.the({
        name: ast.$id+'-ternary-colon',
        sort: [0.6, ast.$id]
      }).the({
        name: ast.$id+'-ternary-colon-text',
        sort: [0.1, ast.$id+'-ternary-colon'],
        fill: ':',
      });

      // Alternate (else part) rendering
      if (ast.alternate) {
        ast.alternate.up = ast;
        var alt_path = render.path(ast, {object: ast.alternate});
        render.side(ast.alternate, ast, alt_path, 'ifFalse');
      }
      
      return; // Exit early as we've handled the entire conditional
    }

    // The original rendering for non-new expressions:
    if (left) {
      path = render.path(ast, {object: left})
      //if(path.length > 3){ path = [path[0], String.fromCharCode(8230)].concat(path.slice(-2)) } // FEATURE!
      left.up = ast;
      render.side(left, ast, path, 'left');
    }
    
    // Special handling for nullish coalescing operator
    if (operator === '??' || ast.isNullishCoalescing) {
      render.the({
        name: ast.$id+'-nullish',
        sort: [0.1, ast.$id]
      }).the({
        name: ast.$id+'-nullish-text',
        sort: [0.1, ast.$id+'-nullish'],
        fill: '??',
      });
    } else {
      // operator = ('=' == operator? ':' : operator);
      operator && render.the({
        name: ast.$id+'-act',
        sort: [operator == 'new' ? -0.1 : 0.1, ast.$id]
      }).the({
        name: ast.$id+'-act-text',
        sort: [0.1, ast.$id+'-act'],
        fill: operator || '',
      });
    }
  
    if (right) {
      right.up = right.up || ast;
      path = render.path(ast, {object: right})
      render.side(right, ast, path);
    }
  }
  // Render the side (additional) component of an expression, such as property access or arguments.
  render.side = function(right, ast, path, t){
    // Special handling for ternary operator parts
    if (t === 'condition' || t === 'ifTrue' || t === 'ifFalse') {
      // Different styling for different parts of the ternary expression
      render.the({
        name: ast.$id + '-' + t,
        sort: [t === 'condition' ? 0.2 : (t === 'ifTrue' ? 0.4 : 0.7), ast.$id]
      });
      
      // Check for nested ternary conditionals
      if (t === 'ifFalse' && right && right.type === 'ConditionalExpression') {
        // Nested conditional within the 'else' part
        render(right);
        return;
      }
      
      // If the right side is a simple value or identifier
      if (right.raw || 'Identifier' == right.type) {
        render.the({
          name: ast.$id + '-' + t + '-text',
          sort: [0.1, ast.$id + '-' + t],
          fill: right.raw || right.name || '?'
        });
        return;
      }
      
      // Otherwise, render the component normally
      render(right);
      return;
    }
    
    // Regular handling for non-ternary components
    if (right.raw || 'Identifier' == right.type) {
      render.the({
        name: ast.$id + '-' + (t || 'right'),
        sort: [0.1, ast.$id]
      }).the({
        name: ast.$id + '-' + (t || right) + '-text',
        sort: [0.1, ast.$id + '-' + (t || 'right')],
        fill: right.raw || right.name || '?'
      });
    } else if (right.async) {
      render.the({
        name: ast.$id + '-async',
        fill: "async",
        sort: [0.1, ast.$id],
      });
    } else if (right.type === 'ClassDeclaration') {
      render.the({
        name: ast.$id + '-class',
        fill: "class",
        sort: [0.1, ast.$id],
      });
      
    } else if (right.property) {
      if (right?.object?.type === "ThisExpression") {
        console.log("ThisExpression:", right);
        // render.list(right, [right.object, right.property], '', '.', '');
        right.up = ast;
        render(right)
      } else {
        render.the({ // RIGHT
          name: ast.$id + '-' + (t || 'right'),
          sort: [0.1, ast.$id]
        }).the({
          name: ast.$id + '-' + (t || 'right') + '-text',
          sort: [0.1, ast.$id + '-' + (t || 'right')],
          fill: path.join(" . ")
        });
      }
      } else if (right instanceof Array && right.length > 0 && !ast.renderedArgs) {
        render.list(ast, right, '(', ',', ')');
    } else if (right.argument && right.operator) {
        right.$id = right.$id || render.id(right);
        right.up = ast;
      
        render.expression(right, right.prefix ? null: right.argument, right.operator, right.prefix ? right.argument: null);
      } else if (right.callee || right.operator) {
        right.up = ast;
        render(right);
      } else if (right.elements) {
        render.the({ // make view
          name: right.$id = right.$id || render.id(right),
          sort: [0.1, ast.$id]
        });
        render.list(right, right.elements);
      } else if (right.properties) {
        render.the({ // make view
          name: right.$id = right.$id || render.id(right),
          sort: [0.1, ast.$id]
        });
        render.list(right, right.properties, '{', ',', '}');
      } else if (right.body) {
        right.up = right.up || ast
        right.$id = right.$id || render.id(right);
        render.the({ // RIGHT
          name: right.$id,
          sort: [0.1, right.up.$id],
          fill: render.fill(right)
        });
        render(right);
      } else if (right.argument) {
        right.up = right.up || ast
        right.$id = right.$id || render.id(right);
        render.the({ // RIGHT
          name: right.$id,
          sort: [0.1, right.up.$id],
          fill: render.fill(right)
        });
        render(right);
      }
  }

  // Utility functions
  render.path = function (ast, a) {
    var path = [];
    while(a = a.object){
      if (a.callee) { a.up = ast; render(a) }
      // property.name, property.raw, name, raw
      path.push((a.property||'').name||a.name||'');
    }
    return path.reverse();
  }

  // Utility to render a list of nodes. 's' is the start delimiter, 'b' is the separator, and 'e' is the end delimiter.
  render.list = function(ast, steps, s, b, e){
    if (!ast) return;
    if (!(steps instanceof Array)) {
      steps = [steps] || [];
    }
    // if (steps.length === 0) return;  // <== New: skip rendering if there are no items

    if(ast.elements){ s = '[', b = ',', e = ']' }
    // if(ast.expression){ s = '(', b = ',', e = ') => ' }
    if (ast.declarations) { s = ast.kind, b = ',', e = '' }
    if (ast.specifiers) { s = 'import {', b = ',', e = '}' }
    // if(ast.params){ s = '<', b = '&', e = '>' }
  
    // console.log("???", s,b,e, ast.$id);
    var id = render.id(ast);
    if(s){
      render.the({ // ACT
        name: id, 
        sort: [0.1, ast.$id],
      }).the({
        name: id+'-text',
        sort: [0.1, id],
        fill: s
      });
    }
    steps.forEach(function(a, i){
  
      i && render.the({
        name: id+'-'+i,
        sort: [0.1, ast.$id],
        fill: b || ""
      });
  
      if(a?.expression && a.expression !== true){
        a.expression.up = a;
        a = a.expression;
      }
  
      a.up = ast;
      render.the({
        name: a.$id = a.$id || render.id(a),
        size: [[1,'~'],[1,'~']],
        sort: [0.1, ast.$id]
      });
      render(a);
    });

    if(e){
      console.log("???--", ast.$id, s,b,e);  
      render.the({ // ACT
        name: id+'-end',
        sort: [0.1, ast.$id],
      }).the({
        name: id+'-end-text',
        sort: [0.1, id+'-end'],
        fill: e
      });
    }
  }
  // -------------------------------------------------------------------------------
  // Utility functions for render: color fill generation, id generation, messaging, etc.
  // -------------------------------------------------------------------------------
  render.fill = function() {
    return [Math.random()-0.2, Math.random()-0.2, Math.random()-0.2, 0.3];
  };

  render.id = function (ast) {
    return Math.random().toString(32).slice(2);
  };

  render.the = function (o) {
    // console.log("...O", o)
    postMessage([o]);

    // console.log('...up', postMessage({ get: o.sort[1], how: "store" }));
    return render;
  };
</script>